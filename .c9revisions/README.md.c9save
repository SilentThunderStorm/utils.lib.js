{"ts":1381715371040,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"utils.lib.js\n============\n\nA JavaScript utilities Library\n"]],"start1":0,"start2":0,"length1":0,"length2":58}]],"length":58}
{"contributors":[],"silentsave":false,"ts":1381715385881,"patch":[[{"diffs":[[0," Library"],[-1,"\n"]],"start1":49,"start2":49,"length1":9,"length2":8}]],"length":57,"saved":false}
{"ts":1381720047246,"patch":[[{"diffs":[[0," Library"],[1,"\n\ntimer ->\n\n----------------------------------------------------------------------------------------------------------------\n\nOverview:\n\nTimer is an attempt at increased responsiveness, accuracy, and flexibility from JavaScript timers.\n\nThe traditional JavaScript timers, setInterval and setTimeout are generally unreliable timekeepers, often\nallowing as much as 200 milliseconds to go by before triggering, depending upon script load.  In cases\nwhere a script has a lot going on (for example, in cases of heavy graphics use, or animations) the script\ngenerally requires MORE timer sensitivity, not less.\n\nIn addition, setInterval and setTimeout allow only a single callback for completion of the timer, and can\nonly be stopped or cleared by destroying any reference to the timer, whereupon they are garbage collected.\n\nThis timer hooks itself into the requestAnimationFrame callback, which allows it to be accurately responsive\nwithin 17 or 18 milliseconds. This *IS* dependant on the screen draw rate, but JavaScript will do everything\nin its power to retain 60 frames per second, which is where this number is derived.\n\nThis also allows the timer to be graphics friendly, as each time it is active is during a redraw event. This,\nin turn means that it may be used for updating graphic objects without causing an additional redraw, thereby\npreserving script performance.\n\nIn addition, this timer is able to be paused and continued while retaining an accurate count of the time \nelapsed.\n\nIt is also able to callback functions when started, paused, restarted, aborted, reset, or, of course, when \nit finishes.\n\n----------------------------------------------------------------------------------------------------------------\n\nUsage:\n\n    var a = new timer( duration, callbacks, options );\nor  var a = timer( duration, callbacks, timer );\n\nOnly two parameters are required, a duration and a callback used for timer completion.\n\nDuration should be listed as the required number of milliseconds for the timer to run to completion. In the case\nof a repeated timer (like a setInterval), then this will be the number of elapsed milliseconds before the timer\nrepeats.\n\nBoth the 'callbacks' and 'options' parameters expect an object, with appropriate values stored in specific properties.\n\nIt is usually easiest to cast these as object literals, thus:\n\n    a = timer\n    (\n        10000,\n        {\n            onstart:function(){console.log(\"starting countdown...\")},\n            onfinish:function(){console.log(\"countdown finished... BOOM!\")},\n            onprogress:function(value){console.log(\"currently \" + (value*100) + \"% complete\")}\n        },\n        {\n            continuous:false\n        }\n    );\n\nCallbacks: \n\n    onfinish (required) ~ onfinish will be called once the timer has completed its countdown. In the case of a repeated timer,\n                            this callback will fire every time the countdown finishes.\n                            \n    onstart (optional) ~ onstart will fire whenever the timer is told to start. In the case of a timer which has been paused,\n                            onstart will fire when it is restarted. This callback will pass a single parameter to the callback,\n                            if the timer is starting fresh, it will send a string with the value \"Starting\", while if it is\n                            restarting a paused timer, it will pass the string \"Restarting\".\n                            \n    onprogress (optional) ~ onprogress will fire EVERY TIME the timer updates itself, this will be on every screen redraw. It\n                            is possible to hook this to draw events, so that objects will always redraw during this period.\n                            In effect, this is very similar to requestAnimationFrame, with the exception that this callback\n                            passes the percentage of timer completion to the callback function. This may be, for example, an\n                            easing function, which would then convert this percent of progress into another value based on \n                            the easing function used.\n                            \n    onpause (optional) ~ onpause will be fired whenever the timer is paused. This will pass to the callback function a\n                            parameter of type number representing the elapsed time ACCORDING TO THE TIMER. This time will not\n                            include time spent paused, and will not persist throughout reset or abort events.\n    \n    onabort (optional) ~ this callback will fire whenever the timer is cancelled. A cancelled timer loses all information about\n                            the countdown which was in progress, and the timer will not restart unless it is first reset. This\n                            will not pass a parameter to the callback function. If it is crucial to your application to stop the \n                            timer and to receive a callback parameter representing the time at which the timer was stopped, \n                            then you should be calling 'pause' and 'reset' instead.\n                            \n    onreset (optional) ~ this callback will fire whenever the counter is reset. Resetting the timer WILL NOT STOP the timer, it\n                            will simply clear the timers state of progress, in effect starting the timer over. A reset will also\n                            be required to restart a timer which has been intentionally aborted. Reset does not pass a parameter \n                            to the callback function. If it is crucial to your application to receive notification of the progress\n                            of the timer when it was reset, you may wish to call pause instead, and then reset the timer.\n                            \nOptions:\n\n    continuous (optional) ~ Currently, this is the only enabled option (others will be forthcoming as time presents itself). This \n                            should be set as a Boolean flag set directly as true or false. This CAN use a string, just be aware that \n                            this uses the default typecasting used by JavaScript... in other words, be aware that 'false' evaluates \n                            to true. If this flag is set to be true, then the timer will not stop on completion, but will reset itself \n                            and continue to count down. In effect, setting this flag to true will convert the timer from a setTimeout \n                            style timer into a setInterval style timer. Callbacks, such as onfinish, will continue to fire normally.\n                            \n                            This parameter is optional, and will default to false if missing.\n                            \nProperties:\n\n    This timer object also exposes several punblic properties which may be useful.\n    \n    These properties are currently writable, and writing to many of these properties WILL cause problems with the timers function. The\n    next iteration of this timer may include proper GETters and SETters, which will alleviate this flaw, yet is not included in this \n    version to allow the greatest compatability, specifically with Internet Explorer 8 or below. As this browser is currently at 1%\n    market saturation, this support will be removed in following versions.\n    \n    timer.duration ~ The total duration of the timer in milliseconds.\n    timer.progress ~ A running percentage, expressed as a float between 0 and 1, indicating the percentage of timer completion.\n    timer.status ~ Holds a string representing the current state of the timer, \"ready\", \"running\", \"paused\", or \"aborted\".\n    timer.time ~ A running total of the amount of time that the timer has been running; this does not include time spent paused, and \n                    does not persist through reset or abort calls.\n                    \nMethods:\n\n    timer.start() ~ Starts the timer when it is ready, restarts the timer when it is paused. Will call the onstart callback, if set.\n    timer.pause() ~ Pauses a timer. Calls the onpause callback, if set.\n    timer.reset() ~ Resets the current time on the timer to zero, effectively starting it fresh. Does not stop a running timer.\n    timer.abort() ~ Stops a timer, and clears its set time. Cannot be restarted by timer.start(), and must be reset to be restarted.\n    "]],"start1":49,"start2":49,"length1":8,"length2":8391}]],"length":8440,"saved":false}
